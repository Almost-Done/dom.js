#!/usr/local/bin/node
// -*- mode: javascript; -*-

// TODO:
//
// The -D output is including pop opcodes with zero counts on
// executed lines that don't have any branches, so they are
// incorrectly being reported as having partial coverage.
// Probably just filter out 0 count pops on lines that have other
// non-zero opcodes, while reading the lines.
//
// -d option that takes a directory name and generates static HTML
// coverage files in that directory.
// 
// See if I can make it work on the -D output of an unpatched
// spidermonkey debug build.  It would have to ignore more lines and
// it would have to be able to read from stdin, which would mean
// converting to a streaming parser rather than reading the whole file
// at once and breaking into lines.
//

var assert = require("assert");
var fs = require("fs");
var path = require("path");
var console = require("console");
var http = require("http");
var util = require("util");

function Opcode(line, assembly) {
    this.line = line;
    this.assembly = assembly;
    this.count = 0;
}

function Line(file, number) {
    this.file = file;
    this.number = number;
    this.opcodes = {};  // Map pc to Opcode object
}

Line.prototype.addOpcode = function(pc, count, assembly) {
    var opcode = this.opcodes[pc];
    if (!opcode) {
        opcode = new Opcode(this, assembly);
        this.opcodes[pc] = opcode;
    }
    else {
        // Each time we get the same pc it had better have the same
        // opcode associated with it
        assert.equal(assembly, opcode.assembly, "different assembly for " +
                     this.file.name + ":" + this.number + ":" + pc + 
                     "\n\t" + assembly + " != " + opcode.assembly);
    }

    // Adjust the count for this opcode.
    opcode.count += count;
    this._counts = null;  // clear cache
};

// Return an array of the counts for this line.  If all opcodes have
// the same count, then this will be a single element array.  If the line
// includes a branch then there may be two or three branches.  The counts will
// be sorted from fewest to most.
Line.prototype.counts = function() {
    if (!this._counts) {
        var min = Infinity, max = 0;
        var rawcounts = [];

        for(var pc in this.opcodes) {
            var c = this.opcodes[pc].count;
            min = Math.min(min, c);
            max = Math.max(max, c);
            rawcounts.push(c);
        }

        var counts;

        if (min === max) counts = [min];  // special case: all lines are same
        else {
            rawcounts.sort(function(a,b) { return a-b; });  // Numerical order
            
            // Remove duplicates so only the unique counts are listed here
            var counts = [];
            counts[0] = rawcounts[0];
            for(var i = 1, j = 0; i < rawcounts.length; i++) {
                if (rawcounts[i] === counts[j]) continue;
                counts[++j] = rawcounts[i];
            }
        }            
        this._counts = counts;
    }

    return this._counts;
}

// Return coverage for this line.  One of the strings "full", "some", "none"
Line.prototype.coverage = function() {
    var counts = this.counts();
    if (counts[0] > 0) return "full";
    if (counts.length > 1) return "some";
    return "none";
}

function File(name) {
    this.name = name;
    this.lines = {};
}

File.prototype.line = function(linenum) {
    if (!this.lines[linenum]) {
        this.lines[linenum] = new Line(this, linenum);
    }
    return this.lines[linenum];
};

File.prototype.coverage = function() {
    var covered = 0, partial = 0, uncovered = 0;

    for(var linenum in this.lines) {
        var line = this.lines[linenum];
        switch(line.coverage()) {
        case "full": covered++; break;
        case "some": partial++; break;
        case "none": uncovered++; break;
        }
    }

    return [covered, partial, uncovered];
}

// Return the coverage class for line n of the specified file.
// Lines that don't have executable code will return an empty string.
File.prototype.coverageClass = function(n) {
    if (n in this.lines) 
        return " " + this.lines[n].coverage();
    return "";
}

// Return the profile class for line n.  This will be based on the 
// base-10 logarithm of the number of executions
File.prototype.profileClass = function(n) {
    if (!(n in this.lines)) return "";
    var counts = this.lines[n].counts();
    var count = counts[counts.length-1];  // the last one is biggest
    return " p" + log(count);

    function log(x) {
        if (x <= 0) return 0;
        return Math.min(Math.floor(Math.log(x)/Math.LN10), 9);
    }
}

File.prototype.detail = function(n) {
    if (!(n in this.lines))
        return "No executable code here";
    var counts = this.lines[n].counts();
    if (counts.length === 1 && counts[0] === 0)
        return "This line was never executed";
    if (counts[0] === 0) 
        return "Partial coverage: " + counts.join(',');
    if (counts.length === 1) 
        return "Full coverage: " + counts[0];
    return "Full coverage, with branches: " + counts.join(',');
}

// Pass in an array of filenames of the -D output files to parse.
// Returns an object that maps JS source filenames to File objects
// Each File object includes a map of line numbers to Line objects.
// Each Line object includes a map of bytecode PC addresses to Opcode objects
function parse(datafiles) {

    var START = /^--- PC COUNTS ([^:]+):(\d+) ---$/;
    var END = /^--- END PC COUNTS/;
    var DATA = /^(\d+):(\d+)\/(\d+)\/(\d+)\s+x\s+(\d+)\s+(.*)$/;

    // We skip any lines that look like these:
    var skip = {
        "" : true,
        "main:" : true,
        "loc   counts           x line  op" : true,
        "----- ----------------   ----  --" : true,
    }

    var files = {};  // This is the data structure we'll return
    
    if (typeof datafiles === "string") datafiles = [datafiles];

    datafiles.forEach(function(datafilename)  {
        var datafiledir = path.dirname(datafilename);
        var datalines
        var jsfile;  // The current File object

        try {
            datalines = fs.readFileSync(datafilename, 'utf8').split("\n");
        }
        catch(e) {
            console.log("Can't read file %s: %s", datafilename, e.message);
            process.exit(1);
        }

        for(var n = 0; n < datalines.length; n++) {
            var dataline = datalines[n];
            var match;

            if (skip[dataline]) continue;
            if (dataline[0] === "\t") continue;  // lookupswitch data we skip
            if (dataline.match(END)) continue;

            if (match = dataline.match(START)) {
                var jsfilename = path.resolve(datafiledir, match[1]);
                // the filename plus line number identifies the start
                // of the function that is being disassembled. Opcodes are
                // relative to that this
                var jsfuncstart = match[1] + ":" + match[2];
                
                if (!files[jsfilename]) {
                    files[jsfilename] = new File(jsfilename);
                }
                jsfile = files[jsfilename];
            }
            else if (match = dataline.match(DATA)) {
                var pc = match[1] + "@" + jsfuncstart;
                var count = parseInt(match[2], 10) +
                    parseInt(match[3], 10) +
                    parseInt(match[4], 10);
                var linenum = parseInt(match[5], 10);
                var assembly = match[6];

                jsfile.line(linenum).addOpcode(pc, count, assembly);
            }
            else {
                assert.fail("", "", "Can't parse line " + n + ": " + dataline);
            }
        }
    });

    return files;
}

function usage() {
    console.log("usage: profilage [options] datafiles...");
    console.log("Options:");
    console.log("  -q       Quiet: display coverage % only");
    console.log("  -s       Server: run as an HTTP server to display data");
    console.log("           implies -q");
    console.log("  -p port  Port number for server (default: 8000)");
    console.log("  -t file  Display coverage stats for target js file");
    console.log("           default: all files; multiple -t args allowed");
    console.log("  -j       Output coverage stats to stdout in JSON format");
}


// Loop through the command-line arguments collecting input files and options

var datafiles = [];
var quiet = false;   // quiet: only output coverage %
var targets = [];    // Which js files do we want stats on?
var server = false;  // Launch web server for exploring coverage
var port = 8000;
var statistics_data = {};
var output_json = false;

var argv = process.argv;
argv.shift();  // throw away the path to node
argv.shift();  // throw away the path to this script

if (!argv.length) usage();
while(argv.length) {
    var arg = argv.shift();
    switch(arg) {
    case '-q':
        quiet = true;
        break;
    case '-s':
        server = true;
        break;
    case '-p':
        if (!argv.length) usage();
        port = parseInt(argv.shift());
        if (port === 0) usage();
        break;
    case '-t':
        if (!argv.length) usage();
        targets.push(path.resolve(argv.shift()));
        break;
    case '-j':
        output_json = true;
        break;
    default: 
        if (arg[0] === '-') usage();
        datafiles.push(arg);
        break;
    }
}

// Now analyze the data
var data = parse(datafiles);

// And generate our output

// If no targets specified, output all
if (targets.length === 0) { 
    for(filename in data) targets.push(filename);
    targets.sort();         // Alphabetially
}

targets.forEach(function(target, index) {
    var file = data[target];

    // If file is null here look for a file name with the same basename
    // And alter the target in the array
    if (!file) {
        target = path.basename(target);

        for(var filename in data) {
            if (path.basename(filename) === target) {
                target = filename;
                file = data[filename];
                targets[index] = target;
                break;
            }
        }
        if (!file) {
            console.warn("Unknown target file %s", target);
            return; 
        }
    }

    var coverage = file.coverage();
    var covered = coverage[0];
    var partial = coverage[1];
    var uncovered = coverage[2];
    var total = covered + partial + uncovered;

    if (!output_json) {
        if (quiet || server) {
            console.log("%s: %d%", target, percent(covered/total));
        }
        else {
            console.log("%s:\n\t" +
                        "significant lines: %d\n\t" +
                        "          covered: %d (%d%)\n\t" +
                        "partially covered: %d (%d%)\n\t" +
                        "        uncovered: %d (%d%)",
                        target, total,
                        covered, percent(covered/total),
                        partial, percent(partial/total),
                        uncovered, percent(uncovered/total));
        }
    } else {
        statistics_data[target] = {significant: total, covered: covered, partial: partial, uncovered: uncovered}
    }
});

if (output_json) {
    console.log(JSON.stringify(statistics_data));
}

function percent(x) { return Math.round(x*100); }

if (server) {
    var server = http.createServer(function(request, response) {
        if (request.url === "/" || request.url === "/index.html") {
            response.statusCode = 200;
            response.setHeader("Content-Type", "text/html");
            writeIndexFile(targets, response);
        }
        else if (data[request.url]) {
            // If it is the name of one of our targets
            response.statusCode = 200;
            response.setHeader("Content-Type", "text/html");
            writeCoverageFile(request.url, response);
        }
        else {
            response.statusCode = 404;
            response.setHeader("Content-Type", "text/html");
            response.end("Unknown file: " + request.url);
        }
    }).listen(port, "localhost", function() {
        console.log("Details available at http://localhost:%d", port);
    });
}

var indextitle = "CoverMonkey Code Coverage Report";
var stylesheet = 
    ".line {white-space: pre; font-family: monospace; padding:1px;}" +
    ".full {background-color: #afa}" +     // Full coverage
    ".none {background-color: #faa}" +     // No coverage
    ".some {background-color: #ffa}" +     // Partial coverage
    ".p0 {color:hsl(0,0%,0%)}" +           // Profile classes
    ".p1 {color:hsl(0,10%,5%)}" +          // digit is base-10 logarithm 
    ".p2 {color:hsl(0,20%,10%)}" +         // of # of executions
    ".p3 {color:hsl(0,30%,15%)}" +
    ".p4 {color:hsl(0,40%,20%)}" +
    ".p5 {color:hsl(0,50%,25%)}" +
    ".p6 {color:hsl(0,60%,30%)}" +
    ".p7 {color:hsl(0,70%,35%)}" +
    ".p8 {color:hsl(0,80%,40%)}" +
    ".p9 {color:hsl(0,90%,45%)}" +
    "table {border-collapse:collapse;}" +
    "td, th {border:solid black 1px; padding:3px 5px 3px 5px;}" +
    "th {background-color:#bbb}" +
    ".linenum {float:left; font-weight:bold; text-align:right; margin-right:10px; width:5%}" +
    "";

var index_file_prefix = 
    '<html><head><title>%s</title>' + 
    '<style type="text/css">%s</style></head>' +
    '<body><h1>%s</h1>' + 
    '<table><tr>' +
    '<th>Source File<th>Executable Lines<th>Covered<th>Partial<th>Uncovered' +
    '</tr>';

var index_file_suffix = '</table></body></html>';

var index_file_row =
    '<tr><td>%s<td>%d<td>%d (%d%)<td>%d (%d%)<td>%d (%d%)</tr>';


// Write an HTML summary of the profiling/coverage data to the specified
// stream and call the stream's end() method when done.
function writeIndexFile(targets, stream) {
    stream.write(util.format(index_file_prefix,
                             indextitle, stylesheet, indextitle));

    targets.forEach(function(target) {
        var file = data[target];
        var coverage = file.coverage();
        var covered = coverage[0];
        var partial = coverage[1];
        var uncovered = coverage[2];
        var total = covered + partial + uncovered;
        
        stream.write(util.format(index_file_row, filelink(target), total, 
                                 covered, percent(covered/total),
                                 partial, percent(partial/total),
                                 uncovered, percent(uncovered/total)));
                                 
    });

    stream.end(index_file_suffix);
}

var coverage_file_prefix = 
    '<html><head><title>%s</title>' + 
    '<style type="text/css">%s</style></head>' +
    '<body><h1>%s</h1>' + 
    '';

var coverage_file_suffix = "</body></html>";

var coverage_line =
    '<div class="%s" title="%s"><span class="linenum">%d</span>%s</div>\n';

// Write an HTML page that lists a js source file with color coding to
// indicate coverage and profiling information.  Write to the specified stream
// and close the stream when done
function writeCoverageFile(target, stream) {
    var file = data[target];
    var lines = fs.readFileSync(target, "utf8").split("\n");
    var title = "CoverMonkey Report for " + target;

    stream.write(util.format(coverage_file_prefix, title, stylesheet, title));

    lines.forEach(function(line, linenum) {
        linenum += 1; // line numbers are 1-based, not 0-based
        var c = "line" +
            file.coverageClass(linenum) +
            file.profileClass(linenum);
        var tooltip = file.detail(linenum);
        if (line === "") line = " ";  // To make the HTML format right.
        stream.write(util.format(coverage_line, c, tooltip, linenum, line));
    });

    stream.end(coverage_file_suffix);
}

// Return an <a> tag with a URL that will generate a file listing
function filelink(target) {
    return '<a href="' + target + '">' + target + '</a>';
}

