#!/usr/local/bin/node
// -*- mode: javascript; -*-
//
// TODO:
//
// The dead code analysis is saying that catch blocks are unreachable.
// I think they must be their own entry points.  Need to ask someone on #jsapi
// 
// I'm getting warnings about unreachable non-zero opcodes...
// 
// The HTML output needs to be searchable for uncovered, partial and dead lines
//    done
// 
// give lines an id with line number so they can be used in the URL
//   done
//
// Implement a -l option to actually list the line numbers that need attention?
//
// Clean up the code: its gotten really messy.
//
// 
// Another benefit of analzying entire functions at a time: based on the 
// length of the function (in lines or (easier) opcodes) I can distinguish
// inner from outer functions.  Currently, with this code:
// 1: function a() { 
// 2:    function b() { foo(); }
// 3: }
// Both function a and b have opcode 0 mapping to line 2.  As currently
// written I can't really distinguish the two cases and the counts get
// conflated, I think.  But if I knew where the end of the function was,
// I could give each opcode a unique prefix or suffix.
// Actually, the code above is probably okay currently because I use the 
// start line of each function as an opcode prefix.  But if the first newline
// was removed, I'd be in trouble.
//




var assert = require("assert");
var fs = require("fs");
var path = require("path");
var console = require("console");
var http = require("http");
var util = require("util");

function usage() {
    console.log("usage: CoverMonkey [options] [<file>]");
    console.log("Reads js -D data from <file> or stdin if no file specified.");
    console.log("Options:");
    console.log("  -q       Quiet: display coverage % only");
    console.log("  -s       Server: run as an HTTP server to display data");
    console.log("           implies -q");
    console.log("  -p port  Port number for server (default: 8000)");
    console.log("  -t file  Display coverage stats for target js file");
    console.log("           default: all files; multiple -t args allowed");
    console.log("  -d dir   Output HTML coverage files to directory dir");
    process.exit(1);
}


// Loop through the command-line arguments collecting input files and options
var options = {
    filename: null,
    input: null,
    inputdir: null,
    quiet: false,     // quiet: only output coverage %
    targets: [],      // Which js files do we want stats on?
    server: false,    // Start web server for exploring coverage
    port: 8000,
    outputdir: null
};


process.argv.shift();  // throw away the path to node
process.argv.shift();  // throw away the path to this script

while(process.argv.length) {
    var arg = process.argv.shift();
    switch(arg) {
    case '-q':
        options.quiet = true;
        break;
    case '-s':
        options.server = true;
        break;
    case '-p':
        if (!process.argv.length) usage();
        options.port = parseInt(process.argv.shift());
        if (options.port === 0) usage();
        break;
    case '-t':
        if (!process.argv.length) usage();
        options.targets.push(path.resolve(process.argv.shift()));
        break;
    case '-d':
        if (!process.argv.length) usage();
        if (options.outputdir) usage(); // only specify one
        options.outputdir = path.resolve(process.argv.shift());
        break;
    default: 
        if (options.filename) usage(); // One file only
        options.filename = arg;
        options.input = fs.createReadStream(options.filename,
                                            { encoding: "utf8"});
        options.inputdir = path.dirname(options.filename);
        break;
    }
}

// If no input file was specified, then read text from standard in
if (!options.input) {
    process.stdin.resume();
    process.stdin.setEncoding('utf8');
    options.input = process.stdin;
    options.inputdir = process.cwd();
}

parseScripts(options.input, reportCoverage);


const SCRIPT_START = /^--- SCRIPT ([^:]+):(\d+) ---$/;
const SCRIPT_END = /^--- END SCRIPT/;
const SCRIPT_DATA = /^(\d+):(\d+)\/(\d+)\/(\d+)\s+x\s+(\d+)\s+(.*)$/;


// Read a stream of -D data and parse it. Interpret filenames relative to
// the specified directory.  If stream is stdin then any lines before the
// beginning of the -D data are printed to stdout.
function parseScripts(stream, callback) {
    var fragment = "";  // line fragments we haven't processed yet
    
/*
    // These are the state variables used across invocations of parseLine()
    var files = {}; // The return value: maps filenames to File objects
    var jsfile;     // The current File object we're adding data to
    var funcid;     // A file:line pair that identifies the start of the
                    // function currently being disassembled. Used with opcodes
                    // for disambiguation
*/

    var scripts = [];   // Array of Script objects that hold the data
    var scriptMap = {}; // String->Script map for detecting duplicate scripts

    stream.on('data', function(chunk) {
        // Add any pending fragment to this chunk and break into lines
        var lines = (fragment + chunk).split("\n");
        
        // The last element of the array is an unterminated line
        fragment = lines.pop();
        
        // Now process the complete lines we got
        lines.forEach(processLine);
    });

    stream.on('end', function() {
        if (fragment != "") processLine(fragment);

        if (scripts.length === 0) {
            console.log("CoverMonkey: No coverage data to process.\n" +
                        "CoverMonkey: Are you using a debug build of spidermonkey?");
            process.exit(0);
        }

        callback(scripts);
    });

    var inscript = false; // Are we collecting a script or just echoing lines?
    var scriptlines;

    function processLine(dataline) {
        if (inscript) {
            scriptlines.push(dataline);
            if (dataline.match(SCRIPT_END)) {
                // Skip initial dummy script
                if (scriptlines[0] !== "--- SCRIPT (null):0 ---") {
                    var script = new Script(scriptlines);
                    var string = script.toString();

                    var existingScript = scriptMap[string];
                    if (existingScript) {
                        // We've seen this script before
                        existingScript.addCounts(script);
                    }
                    else {
                        scripts.push(script);
                        scriptMap[string] = script;
                        script.checkReachability();
                    }

/*                    
                    console.log("Script: %s", script.name);
                    script.checkReachability();
                    for(var i = 0; i < script.opcodes.length; i++) {
                        if (!script.opcodes[i].reachable)
                            console.log("Opcode %d at pc %d is not reachable",
                                        i, script.opcodes[i].pc);
                    }
*/
                }
                
                scriptlines = null;
                inscript = false;

            }
        }
        else {
            if (dataline.match(SCRIPT_START)) {
                inscript = true;
                scriptlines = [ dataline ];
            }
            else if (stream === process.stdin) {
                console.log(dataline);
            }
        }
    }        
}

/*
 * Parse an array of lines to create a Script object.
 * "Script" is used in the SpiderMonkey internals sense: it is the body
 * of a JS function or the JS toplevel code, or an eval string.
 * 
 * Scripts have a name which is a (hopefully) unique id that includes the
 * source filename and starting line number. That isn't enough to be unique
 * because in "function a() { function b() {}}" both scripts have the same
 * file and line number. So I also have to include the ending line number
 * and/or ending opcode in the script name.  I could also include some kind
 * of hashcode of the script's opcodes in the name.  Or just use the
 * entire script disassembly as the name, I suppose.
 * 
 * XXX: Am I ever going
 * to be able to disambiguate functions a and b in the following, though?
 *   function() { function a(){} function b(){} }
 *
 * Instead of having a totally unique name, scripts could also have an 
 * equals() method, I suppose, so that we could detect whether we've already
 * seen a script by that name.  Then each script name could map to an array
 * of scripts, possibly.
 * 
 * Scripts also have a filename property that gives their absolute filename?
 * 
 * In addition to their name, scripts also have an array of opcodes and
 * a map of pc addresses to opcode indexes.
 *
 * Finally, each script has an entry point: the index of the starting opcode.
 * 
 * Each opcode includes its string of assembly code.  
 * And, after the script is analyzed, each opcode will also have a
 * reachable flag to indicate if it can ever actually be executed.
 *
 * Eventually, opcodes will also have flags indicating whether they are
 * the start or end of a non-branching linear sequence.
 */
function Script(lines) {
    var script = this;
    script.opcodes = [];
    script.pcToOpcodeIndex = {};

    lines.forEach(function(dataline) {
        var match;

        if (match = dataline.match(SCRIPT_START)) {
            script.filename = match[1]; 
            script.startline = parseInt(match[2], 10);

            // Script name is supposed to be a unique identifier for
            // the script, but it may need to include the opcodes to 
            // be maximally unique.
            script.name = match[1] + ":" + match[2];
        }
        else if (dataline.match(SCRIPT_END)) {
            return;
        }
        else if (dataline === "main:") {
            script.entrypoint = script.opcodes.length;
        }
        else if (match = dataline.match(SCRIPT_DATA)) {
            var opcode = {
                pc: parseInt(match[1], 10),
                count: parseInt(match[2], 10) +
                    parseInt(match[3], 10) +
                    parseInt(match[4], 10),
                srcline: parseInt(match[5], 10),
                assembly: match[6]
            };

            // Discard the (potentially very long) anonymous function 
            // souce associated with lambda opcodes
            if (opcode.assembly.match(/^lambda /))
                opcode.assembly = "lambda";
            if (opcode.assembly.match(/^deflocalfun /))
                opcode.assembly = "deflocalfun";

            script.pcToOpcodeIndex[opcode.pc] = script.opcodes.length;
            script.opcodes.push(opcode);
        }
        else if (dataline[0] === '\t') {
            // this is part of a switch (or other?) disassembly
            // for the previous opcode, so append it there
            script.opcodes[script.opcodes.length-1].assembly += dataline;
        }
        else {
            // Just ignore lines that we don't recognize.
            // We have to do this because some opcodes like lambda and
            // deflocalfun print out long function bodies on multiple lines
            return;
        }
    });
}

/*
 * XXX: I don't need this anymore since I'm using a toString method
 * that returns a unique string
 *
// Return true if this Script object is the same as that Script object
// This can happen when CoverMonkey is analzying data from multiple
// spidermonkey runs.
Script.prototype.equals = function(that) {
    if (this.name !== that.name) return false;
    if (this.entrypoint !== that.entrypoint) return false;
    if (this.opcodes.length !== that.opcodes.length) return false;

    for(var i = 0; i < this.opcodes.length; i++) {
        var thisop = this.opcodes[i], thatop = that.opcodes[i];
        if (thisop.pc !== thatop.pc) return false;
        if (thisop.srcline !== thatop.srcline) return false;
        if (thisop.assembly !== thatop.assembly) return false;
    }

    return true;
};
*/

// Return a verbose representation of a script.  Distinct scripts will
// always return distinct strings.
Script.prototype.toString = function() {
    var s = this.name + ":" + this.entrypoint + "\n";
    var ops = this.opcodes.map(function(opcode) {
        return opcode.pc + ":" + opcode.srcline + ":"+ opcode.assembly;
    });
    return s + ops.join("\n");
}


// Add the opcode counts from that script to the opcodes in this script.
// This method requires that this.equals(that)
Script.prototype.addCounts = function(that) {
    for(var i = 0; i < this.opcodes.length; i++)
        this.opcodes[i].count += that.opcodes[i].count;
};

Script.prototype.checkReachability = function() {
    var switches = {
        "tableswitch":true,
        "lookupswitch":true,
        "tableswitchx":true,
        "lookupswitchx":true,

    };

    var terminators = {
        "stop": true,
        "return": true,
        "throw": true,
        "retrval":true,
        // treat retsub as a terminator because I treated gosub as a conditional
        "retsub":true
    };


    var unconditionals = {
        "goto": true,
        "gotox":true,
        "default":true,
        "defaultx":true, 
        "filter": true // E4X opcode: we'll probably never see it
    };
    
    var conditionals = {
        "ifeq": true,
        "ifeqx": true,
        "ifne": true,
        "ifnex": true,
        "or":true,
        "orx":true,
        "and":true,
        "andx":true,
        // Treat gosub as a conditional because when it
        // returns the following opcode is reachable
        "gosub":true,
        "gosubx":true,
        "case":true,   
        "casex":true,  
        "ifcantcalltop":true,
        "endfilter": true // E4X opcode: we'll probably never see it
    };


    function reachable(script, opcodeIndex) {
        assert.ok(opcodeIndex < script.opcodes.length);

        var opcode = script.opcodes[opcodeIndex];

        // If this opcode is already marked as reachable, then
        // we've already been here and don't want to loop
        if (opcode.reachable) return;
        

        // Mark this opcode as reachable.
        opcode.reachable = true;

        // Now, based on the opcode, determine which other opcodes
        // are reachable from it.  For most opcodes this will just be the
        // next opcode.  For conditional branches, it will be the next opcode
        // plus the branch target.  For unconditional it will just be
        // the branch target.  For switches, there will be many. 
        // And for things like stop, return and throw, there will be no
        // reachable opcodes.  Just recurse for each reachable opcode.
        var op = opcode.assembly.match(/(\w+)/)[1];

        function branchIndex(assembly) {
            return script.pcToOpcodeIndex[assembly.match(/^\w+\s+(\d+)/)[1]];
        }
        
        if (op in terminators) {
            // This opcode makes the script exit, so nothing is 
            // reachable from here.
            return;
        }
        else if (op in unconditionals) {
            // The unconditional jump target is reachable
            reachable(script, branchIndex(opcode.assembly));
        }
        else if (op in conditionals) {
            // The next opcode and the jump target are both reachable
            reachable(script, opcodeIndex+1);
            reachable(script, branchIndex(opcode.assembly));
        }
        else if (op in switches) {
            // Multiple opcodes are reachable
            // The -D output for switches includes relative jump offsets
            // not absolute ones like those used by jumps

            // Each case is on its own line, starting with the 2nd line
            // The default offset is on the first line after the string "ffset"
            var cases = opcode.assembly.split("\t");

            var offset = parseInt(cases[0].match(/ffset (\d+)/)[1], 10);
            var absolute = opcode.pc + offset;
            var index = script.pcToOpcodeIndex[absolute];
            reachable(script, index);

            for(var i = 1; i < cases.length; i++) {
                offset = parseInt(cases[i].match(/: (\d+)$/)[1], 10);
                absolute = opcode.pc + offset;
                index = script.pcToOpcodeIndex[absolute];
                reachable(script, index);
            }
        }
        else {
            // For any other opcode, just the next one is reachable
            reachable(script, opcodeIndex+1);

            // Mark these opcodes to indicate that they fall-through
            opcode.fallsthrough = true;
        }
    }

    // Mark the entry point of the script as reachable, and
    // from there recursively determine what else is reachable.
    reachable(this, this.entrypoint);
};




/*
 * This is old parseLine() code:
 *
    var linenum = 0;
    var lastopcode;
    const SKIP = {
        "" : true,
        "main:" : true,
    };




        var match;
        linenum++;

        if (!parsing_lines && dataline.match(START)) {
            parsing_lines = true;
        }


        // If we haven't found the first START line, and we're reading
        // from stdin, just write this first line to stdout
        if (!parsing_lines) {
            if (stream === process.stdin) 
                console.log(dataline);
            return;
        }

        if (SKIP[dataline]) return;
        if (dataline[0] === "\t") return;  // lookupswitch data we skip

        if (match = dataline.match(START)) {
            var jsfilename = path.resolve(directory, match[1]);
            // the filename plus line number identifies the start
            // of the function that is being disassembled. Opcodes are
            // relative to that this
            funcid = match[1] + ":" + match[2];
            
            if (!files[jsfilename]) {
                files[jsfilename] = new File(jsfilename);
            }
            // Remember the current File object across invocations
            jsfile = files[jsfilename];
            lastopwasjump = false;
            lastopcode = null;
        }
        else if (dataline.match(END)) {
            parsing_lines = false;
        }
        else if (match = dataline.match(DATA)) {
            var pc = funcid + ":" + match[1];
            var count = parseInt(match[2], 10) +
                parseInt(match[3], 10) +
                parseInt(match[4], 10);
            var linenum = parseInt(match[5], 10);
            var assembly = match[6];
            var opcode = assembly.match(/^(\w+)/)[1];

            // Discard the (potentially very long) anonymous function 
            // souce associated with lambda opcodes
            if (opcode === "lambda") assembly = opcode;

            // Sometimes spidermonkey optimizations cause certain opcodes
            // to appear as if they are never executed. sfink (who implemented
            // the -D option) doesn't think that it is easily possible to
            // figure out exactly when this occurs in general. So here are
            // some heuristic tests to prevent lines from being inappropriately
            // marked as having partial coverage.
            var skip = false;

            // Skip even stops with a non-zero count
            if (lastopcode && opcode === "stop") skip = true;  

            // Setting getters and setters in an object literal
            if (opcode === "initprop" &&
                (lastopcode === "getter" || lastopcode === "setter"))
                skip = true;

            // For loops have this optimization
            if (count === 0 && opcode === "ifne" &&
                (lastopcode === "lt" ||
                 lastopcode === "le" ||
                 lastopcode === "gt" ||
                 lastopcode === "ge"))
                skip = true;

            if (count === 0 && opcode === "pop")
                skip = true;

            if (!skip) 
                jsfile.line(linenum).addOpcode(pc, count, assembly);

            lastopcode = opcode;
        }
        else {
            // -D output prints out anonymous function bodies along with
            // lambda opcodes.  These can be long and can run onto multiple 
            // lines.  So basically we ignore any unknown lines.
            return;
        }
    }
*/

/*
  This is old attempts to get partial line coverage analysis correct.

  

            // Adding thise to the pop test above only makes a small difference.
            // Some of them only work when used in combination
            || opcode === "nope" ||
                 opcode === "ifeq" || opcode === "ifne" || opcode === "trace" ||
                 opcode === "localinc" ||
                 opcode === "blockchain" || opcode === "leaveblock" ||
                   opcode === "goto" ||
                 opcode === "nullblockchain"




            // Sometimes spidermonkey optimizations cause certain opcodes
            // to appear as if they are never executed. sfink (who implemented
            // the -D option) doesn't think that it is easily possible to
            // figure out exactly when this occurs in general. So here are
            // some heuristic tests to prevent lines from being inappropriately
            // marked as having partial coverage.
    var lastopwasjump = false;
    var jumps = { // opcodes that jump to a new pc
        "goto":true, "ifeq":true, "ifne":true, "or":true, "and":true,
        "gosub":true, "case":true, "default":true,
        "gotox":true,"ifeqx":true,"ifnex":true,"orx":true,"andx":true,
        "gosubx":true,"casex":true,"defaultx":true,
    };
    var alwaysignored = { // always skip these opcodes with 0 counts
        "nop":true, "stop":true, "trace":true,
    };
    var ignoreop = { // skip these opcodes if not after a jump
        "pop":true, 
        "ifne":true, "ifeq":true, "ifnex":true, "ifeqx": true,
    };

            if (count === 0 &&
                (alwaysignored[opcode] ||
                 (lastopwasjump === false && ignoreop[opcode]))) {
                lastopwasjump = jumps[opcode] || false;
                return;  // Ignore this opcode
            }

            lastopwasjump = jumps[opcode] || false;
*/

// Analyze the array of Script objects and return an object that maps
// filenames to File objects.
function analyzeScripts(scripts) {
    var data = {};

    scripts.forEach(function(script) {
        var filename = path.resolve(options.inputdir, script.filename);
        if (!(filename in data)) {
            data[filename] = new File(filename);
        }
        var file = data[filename];

        script.opcodes.forEach(function(opcode) {
            file.line(opcode.srcline).addOpcode(script.name + ":" + opcode.pc,
                                                opcode);
        });
    });

    return data;
}


// Generate output
function reportCoverage(scripts) {

    var data = analyzeScripts(scripts);

    var indextitle = "CoverMonkey Code Coverage Report";
    var stylesheet = 
        ".line {white-space: pre; font-family: monospace; padding:1px;}" +
        ".full {background-color: #afa}" +     // green for full coverage
        ".none {background-color: #faa}" +     // red for no coverage
        ".some {background-color: #ffa}" +     // yellow for partial coverage
        ".dead {background-color: #fca}" +     // orange for dead code
        ".p0 {color:hsl(0,0%,0%)}" +           // Profile classes
        ".p1 {color:hsl(0,10%,5%)}" +          // digit is base-10 logarithm 
        ".p2 {color:hsl(0,20%,10%)}" +         // of # of executions
        ".p3 {color:hsl(0,30%,15%)}" +
        ".p4 {color:hsl(0,40%,20%)}" +
        ".p5 {color:hsl(0,50%,25%)}" +
        ".p6 {color:hsl(0,60%,30%)}" +
        ".p7 {color:hsl(0,70%,35%)}" +
        ".p8 {color:hsl(0,80%,40%)}" +
        ".p9 {color:hsl(0,90%,45%)}" +
        "table {border-collapse:collapse;}" +
        "td, th {border:solid black 1px; padding:3px 5px 3px 5px;}" +
        "th {background-color:#bbb}" +
        ".num {float:left; font-weight:bold; text-align:right; margin-right:1%; width:4%}" +
        ".type {float:right; font-weight:bold; font-size:smaller; text-align:left; margin-left:1%; width:4%; }" +
        '.ops { margin-left: 5%; padding-left: 10px; }' +
        '.hidden { display:none; }' +
        "";

    var index_file_prefix = 
        '<html><head><title>%s</title>\n' + 
        '<style type="text/css">%s</style>\n</head>\n' +
        '<body><h1>%s</h1>' + 
        '<table><tr>' +
        '<th>Source File<th>Executable Lines<th>Covered<th>Partial<th>Uncovered' +
        '</tr>\n';

    var index_file_suffix = '</table></body></html>';

    var index_file_row =
        '<tr><td>%s<td>%d<td>%d (%d%)<td>%d (%d%)<td>%d (%d%)</tr>\n';

    var coverage_file_prefix = 
        '<html><head><title>%s</title>' + 
        '<style type="text/css">%s</style></head>' +
        '<body><h1>%s</h1>' + 
        '';

    var coverage_file_script = 
        '<script>' +
        'document.addEventListener("click", clickHandler, true);' +
        'function clickHandler(e) {' +
        '    for(var elt = e.target; elt; elt = elt.parentNode) {' +
        '        if (elt.classList.contains("line")) {' +
        '            elt = elt.getElementsByTagName("table")[0];' +
        ' console.log(elt.classList); ' +
        '            if (elt) elt.classList.toggle("hidden");' +
        ' console.log(elt.classList); ' +
        '            return;' +
        '        }' +
        '    }' +
        '}' +
        '</script>';

    var coverage_file_suffix = "</body></html>";

    // the closing div is output explicitly
    var coverage_line =
        '<div id="%d" class="%s"><span class="num">%d</span>' +
        '<span class="type">%s</span>%s\n';

    var assembly_file_prefix = 
        '<html><head><title>%s</title>' + 
        '<style type="text/css">%s</style></head>' +
        '<body><h1>%s</h1>' + 
        '';
    var assembly_file_suffix = "</body></html>";


    // If no targets specified, output all
    if (options.targets.length === 0) { 
        for(filename in data) {
            // -D outputs a "(null)" script for the toplevel
            if (path.basename(filename) === "(null)") continue;
            options.targets.push(filename);
        }
        options.targets.sort();         // Alphabetially
    }

    options.targets.forEach(function(target, index) {
        var file = data[target];

        // If file is null here look for a file name with the same basename
        // And alter the target in the array
        if (!file) {
            target = path.basename(target);

            for(var filename in data) {
                if (path.basename(filename) === target) {
                    target = filename;
                    file = data[filename];
                    options.targets[index] = target;
                    break;
                }
            }
            if (!file) {
                console.warn("Unknown target file %s", target);
                return; 
            }
        }

        var coverage = file.coverage();
        var covered = coverage[0];
        var partial = coverage[1];
        var uncovered = coverage[2];
        var dead = coverage[3];
        var total = covered + partial + uncovered + dead;

        if (options.quiet || covered === total) {
            console.log("%s: %s%", target, percent(covered/total));
        }
        else {
            console.log("%s: %s%\n\t" +
                        "significant lines: %d\n\t" +
                        "          covered: %d (%s%)\n\t" +
                        "partially covered: %d (%s%)\n\t" +
                        "        uncovered: %d (%s%)\n\t" +
                        "             dead: %d (%d%)",
                        target, percent(covered/total),  total,
                        covered, percent(covered/total),
                        partial, percent(partial/total),
                        uncovered, percent(uncovered/total),
                        dead, percent(dead/total));
        }
    });

    function percent(x) { return (x*100).toFixed(2); }

    if (options.outputdir) {
        var stream = fs.createWriteStream(path.join(options.outputdir,
                                                    "index.html"));
        writeIndexFile(options.targets, stream, true);
        
        options.targets.forEach(function(jsfile) {
            var outputname = jsfile.replace(/\//g, "_") + ".html";
            stream = fs.createWriteStream(path.join(options.outputdir,
                                                    outputname));
            writeCoverageFile(jsfile, stream, false, true);
        });
    }

    if (options.server) {
        var server = http.createServer(function(request, response) {
            if (request.url === "/" || request.url === "/index.html") {
                response.statusCode = 200;
                response.setHeader("Content-Type", "text/html");
                writeIndexFile(options.targets, response);
            }
/*
            else if (request.url.indexOf(":") !== -1) {
                // : separates line number from filename
                var a = request.url.split(":");
                var filename = a[0];
                var linenum = parseInt(a[1]);
                var file = data[filename];
                if (file) {
                    response.statusCode = 200;
                    response.setHeader("Content-Type", "text/html");
                    writeAssemblyFile(filename, linenum, response);
                }
                else {
                    response.statusCode = 404;
                    response.setHeader("Content-Type", "text/html");
                    response.end("Unknown file: " + request.url);
                }
            }
*/
            else if (data[request.url]) {
                // If it is the name of one of our targets
                response.statusCode = 200;
                response.setHeader("Content-Type", "text/html");
                writeCoverageFile(request.url, response);
            }
            else {
                response.statusCode = 404;
                response.setHeader("Content-Type", "text/html");
                response.end("Unknown file: " + request.url);
            }
        }).listen(options.port, "localhost", function() {
            console.log("Details available at http://localhost:%d",
                        options.port);
        });
    }

    // Write an HTML summary of the profiling/coverage data to the specified
    // stream and call the stream's end() method when done.
    // If staticfile is set then we're writing to a file and need to 
    // change the way we generate links
    function writeIndexFile(targets, stream, staticlink) {
        stream.write(util.format(index_file_prefix,
                                 indextitle, stylesheet, indextitle));

        targets.forEach(function(target) {
            var file = data[target];
            var coverage = file.coverage();
            var covered = coverage[0];
            var partial = coverage[1];
            var uncovered = coverage[2];
            var total = covered + partial + uncovered;
            
            stream.write(util.format(index_file_row,
                                     filelink(target,staticlink),
                                     total, 
                                     covered, percent(covered/total),
                                     partial, percent(partial/total),
                                     uncovered, percent(uncovered/total)));
            
        });

        if (targets.length == 1) {
            stream.write('</table><h1>' + targets[0] + '</h1>');
            writeCoverageFile(targets[0], stream, true);
        }
        else 
            stream.end(index_file_suffix);
    }

    // Write an HTML page that lists a js source file with color coding to
    // indicate coverage and profiling information.
    // Write to the specified stream and close the stream when done.
    function writeCoverageFile(target, stream, noprefix, staticlink) {
        var file = data[target];
        var lines = fs.readFileSync(target, "utf8").split("\n");
        var title = "CoverMonkey Report for " + target;

        if (!noprefix) {
            stream.write(util.format(coverage_file_prefix,
                                     title, stylesheet, title));
        }

        // The script make the line numbers clickable.
        // This only works when running as a server, so don't include
        // the script when generating static files.
        if (!staticlink)
            stream.write(util.format(coverage_file_script, target));

        lines.forEach(function(line, linenum) {
            linenum += 1; // line numbers are 1-based, not 0-based
            var cov = file.coverageClass(linenum);
            var c = "line" + cov + file.profileClass(linenum);
            if (line === "") line = " ";  // To make the HTML format right.
            if (cov) cov = "//" + cov;
            stream.write(util.format(coverage_line, linenum, c,
                                     linenum, cov, line));

            var linedata = file.lines[linenum];
            if (linedata) {
                stream.write('<table class="ops hidden">');
                stream.write('<tr><th>Function @<th>PC<th>#<th>Instruction</tr>');
                for(pc in linedata.opcodes) {
                    var opcode = linedata.opcodes[pc];
                    var match = pc.match(/^([^:]+:\d+):(\d+)$/);
                    stream.write(util.format("<tr><td>%s<td>%s<td>%d<td>%s</tr>",
                                             match[1], match[2],
                                             opcode.count, opcode.assembly));
                }
                stream.write("</table>");
            }
            stream.write("</div>\n");  // close the line div
        });

        stream.end(coverage_file_suffix);
    }

/*
    function writeAssemblyFile(target, linenum, stream) {
        var file = data[target];
        var title = "CoverMonkey: " + target + ":" + linenum;
        var line = file.lines[linenum];
        
        stream.write(util.format(assembly_file_prefix, title, stylesheet, title));

        if (!line) {
            stream.write("No executable code on this line")
        }
        else {
            stream.write("<table>");
            for(pc in line.opcodes) {
                var opcode = line.opcodes[pc];
                stream.write(util.format("<tr><td>%s<td>%d<td>%s</tr>",
                                         pc, opcode.count, opcode.assembly));
            }
            stream.write("</table>");
        }
        stream.end(assembly_file_suffix);
    }
*/
    // Return an <a> tag with a URL that will generate a file listing
    function filelink(target, staticlink) {
        if (staticlink) {
            target = target.replace(/\//g, "_") + ".html";
            return '<a href="' + target + '">' + target + '</a>';
        }
        else
            return '<a href="' + target + '">' + target + '</a>';
    }
}

function Line(file, number) {
    this.file = file;
    this.number = number;
    this.opcodes = {};  // Map pc to Opcode object
}

Line.prototype.addOpcode = function(pc, opcode) {
    if (this.opcodes[pc]) {
        console.log("Ignoring duplicate opcode");
        return;
    }
    this.opcodes[pc] = opcode;
};

// Return an array of the counts for this line.  If all opcodes have
// the same count, then this will be a single element array.  If the line
// includes a branch then there may be two or three branches.  The counts will
// be sorted from fewest to most.
// If all opcodes are unreachable, then the returned array will be empty
// indicating that the line is dead code.
// Unreachable opcodes have a count of -1
Line.prototype.counts = function() {
    if (!this._counts) {
        var min = Infinity, max = 0;
        var rawcounts = [];
        var lastopcode;

        for(var pc in this.opcodes) {
            var opcode = this.opcodes[pc];
            var c = opcode.count;
            if (opcode.reachable) {

                // If the last opcode continues unconditionally on to this one
                // then skip this opcode if the count is the same (it might
                // be different if this one is also a jump target).
                // And also skip this opcode if it has a zero count and
                // the last one did not: that is just the sign of an
                // interpreter optimization that messes up the counts
                if (lastopcode && lastopcode.fallsthrough) {
                    if (c === lastopcode.count) continue;
                    if (c === 0 && lastopcode.count !== 0) continue;
                }

                min = Math.min(min, c);
                max = Math.max(max, c);
                rawcounts.push(c);
            }
            else {  // Unreachable opcode
                if (c !== 0)
                    console.log("WARNING: unreachable opcode with non-0 count");
                rawcounts.push(-1);
            }

            lastopcode = opcode;
        }

        var counts;

        
        if (min === max && min >=0) {      // Special case: all lines are same
            counts = [min];  
        }
        else if (rawcounts.length === 1 && rawcounts[0] === -1) {
            // A single unreachable opcode.  If it is a stop opcode, then
            // this isn't really a dead line and should be treated as an
            // insignificant line instead.
            if (this.opcodes[Object.keys(this.opcodes)[0]].assembly === "stop")
                counts = [];
        }
        else {
            rawcounts.sort(function(a,b) { return a-b; });  // Numerical order
            
            // Remove duplicates so only the unique counts are listed here
            var counts = [];
            counts[0] = rawcounts[0];
            for(var i = 1, j = 0; i < rawcounts.length; i++) {
                if (rawcounts[i] === counts[j]) continue;
                counts[++j] = rawcounts[i];
            }
        }            
        this._counts = counts;
    }

    return this._counts;
}

// Return coverage for this line.
// One of the strings "full", "some", "none", "dead" or ""
Line.prototype.coverage = function() {
    var counts = this.counts();
    // We return "" if the code should be treated as insignificant code
    // like comments and whitespace.  This happens when there is a single
    // unreachable stop opcode
    if (counts.length === 0) return "";

    if (counts[0] > 0) return "full";
    if (counts.length === 1) {
        if (counts[0] === 0) return "none";
        if (counts[0] === -1) return "dead";
    }
    return "some";
}

function File(name) {
    this.name = name;
    this.lines = {};
}

File.prototype.line = function(linenum) {
    if (!this.lines[linenum]) {
        this.lines[linenum] = new Line(this, linenum);
    }
    return this.lines[linenum];
};

File.prototype.coverage = function() {
    var covered = 0, partial = 0, uncovered = 0, dead = 0;

    for(var linenum in this.lines) {
        var line = this.lines[linenum];
        switch(line.coverage()) {
        case "full": covered++; break;
        case "some": partial++; break;
        case "none": uncovered++; break;
        case "dead": dead++; break;
        case "": // do nothing in this case
        }
    }

    return [covered, partial, uncovered, dead];
}

// Return the coverage class for line n of the specified file.
// Lines that don't have executable code will return an empty string.
File.prototype.coverageClass = function(n) {
    if (n in this.lines) 
        return " " + this.lines[n].coverage();
    return "";
}

// Return the profile class for line n.  This will be based on the 
// base-10 logarithm of the number of executions
File.prototype.profileClass = function(n) {
    if (!(n in this.lines)) return "";
    var counts = this.lines[n].counts();
    var count = counts[counts.length-1];  // the last one is biggest
    return " p" + log(count);

    function log(x) {
        if (x <= 0) return 0;
        return Math.min(Math.floor(Math.log(x)/Math.LN10), 9);
    }
}

/*
File.prototype.detail = function(n) {
    if (!(n in this.lines))
        return "No executable code here";
    var counts = this.lines[n].counts();
    if (counts.length === 1 && counts[0] === -1)
        return "Dead code: this line can never be executed";
    if (counts.length === 1 && counts[0] === 0)
        return "This line was never executed";
    if (counts[0] === 0) 
        return "Partial coverage: " + counts.join(',');
    if (counts.length === 1) 
        return "Full coverage: " + counts[0];
    return "Full coverage, with branches: " + counts.join(',');
}
*/
